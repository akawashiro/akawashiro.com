# Linux のローダを置き換え可能な sloader を開発しています
## ローダとは何か
Linuxで実行可能なバイナリを[execve(2)](https://man7.org/linux/man-pages/man2/execve.2.html)を使って実行するとき、その実行パスは大きく2つに分類されます。
- Linux カーネルが直接、実行可能なバイナリをメモリ空間にロードする
- バイナリが指定したローダ[^1]が実行可能なバイナリをメモリ空間にロードする

`readelf -l` でバイナリの `PT_INTERP` を見ると、そのバイナリがどちらの方法で起動されるかを確認できます。ほとんどの場合、`Requesting program interpreter: /lib64/ld-linux-x86-64.so.2` と書いてあり、これは「バイナリが指定したローダが実行可能なバイナリをメモリ空間にロードする」ことを意味します。

```
> readelf -l $(which nvim) | grep INTERP -A 2
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

`/lib64/ld-linux-x86-64.so.2` はバイナリのロード時に以下を行います。
- そのバイナリが必要とする共有ライブラリの検索
- 共有ライブラリとバイナリのメモリ空間へのロード
- 共有ライブラリとバイナリ中のシンボル解決

`/lib64/ld-linux-x86-64.so.2` の挙動を正確に理解することは重要です。例えば、LD_PRELOADやLD_AUDITなどの環境変数による便利なハックはローダの処理を変更することで実現されています。`/lib64/ld-linux-x86-64.so.2` の挙動を理解していれば、これらの環境変数で何が可能であり何が不可能かを推測できるようになります。また、[https://github.com/akawashiro/sold](https://github.com/akawashiro/sold) のようなソフトウェアの制作にはその理解が必要不可欠です。

## `/lib64/ld-linux-x86-64.so.2` の問題点
`/lib64/ld-linux-x86-64.so.2` は GNU libc の一部として Linux にインストールされており、そのソースコードはすべて[公開](https://www.gnu.org/software/libc/sources.html)されています。しかし、公開されているソースコードから理解する`/lib64/ld-linux-x86-64.so.2` の挙動にあたっては以下の2つの問題があります。

1つ目の問題は、GNU libcのソースコードは読みにくい点です。GNU libcは歴史の長いソフトウェアでC言語で書かれています。また、複数のアーキテクチャの移植可能な移植性を求められます。このため、ソースコードの至る部分でマクロが多用されており、プログラムの流れを追うのが難しくなっています。

2つ目の問題は、`libc.so` の初期化とプログラムのロードが同時に行われいて、ロード部分だけを分離して理解することができない点です。`libc.so` とはいわゆる標準Cライブラリで、バイナリが `/lib64/ld-linux-x86-64.so.2` によってロードされるときはほぼ確実に同時にロードされます。`libc.so` と `/lib64/ld-linux-x86-64.so.2` は同じパッケージに存在し、2つのコンポーネントの役割分担が明示的にドキュメントされていないません。このため、ロードだけ、もしくは `libc.so` だけを分離して理解し、別のソフトウェアに切り出すことは非常に難しくなっています。

## sloader
上で述べた問題を解決するため、`/lib64/ld-linux-x86-64.so.2` を置き換え可能な新しいローダを開発することにしました。このローダの名前は `sloader` です。リポジトリは [https://github.com/akawashiro/sloader/](https://github.com/akawashiro/sloader/) にあります。`sloader` の開発にあたっては次の2つを基本的な原則としています。

1つ目の原則は、C言語ではなくモダンなC++を使う、です。C++20までのモダンなC++の機能を使ってちょっとでも可読性を上げることを狙っています。Rustを採用することも考えたのですが、GNU libcのソースコードを参照しながら開発することを考えると、C言語との互換性がある言語のほうが良いと判断しました。

2つ目の原則は、`libc.so` の初期化はやらない、です。ロード部分だけを理解するのが目的なので複雑怪奇な `libc.so` の初期化はやりません。というよりできませんでした。

## sloader の現状

[^1]: ローダはダイナミックリンカと呼ばれることもありますが、この記事では「ローダ」で統一します。
