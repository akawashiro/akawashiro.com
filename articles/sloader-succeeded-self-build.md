# Linux のローダを置き換え可能な sloader を開発しています
## ローダとは何か
Linuxで実行可能なバイナリを[execve(2)](https://man7.org/linux/man-pages/man2/execve.2.html)を使って実行するとき、その実行パスは大きく2つに分類されます。
- Linux カーネルが直接、実行可能なバイナリをメモリ空間にロードする
- バイナリが指定したローダが実行可能なバイナリをメモリ空間にロードする

`readelf -l` でバイナリの `PT_INTERP` を見ると、そのバイナリがどちらの方法で起動されるかを確認できます。ほとんどの場合、`Requesting program interpreter: /lib64/ld-linux-x86-64.so.2` と書いてあり、これは「バイナリが指定したローダが実行可能なバイナリをメモリ空間にロードする」ことを意味します。

```
> readelf -l $(which nvim) | grep INTERP -A 2
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

`/lib64/ld-linux-x86-64.so.2` はバイナリのロード時に以下を行います。
- そのバイナリが必要とする共有ライブラリの検索
- 共有ライブラリとバイナリのメモリ空間へのロード
- 共有ライブラリとバイナリ中のシンボル解決

LD_PRELOADやLD_AUDITなどの環境変数による便利なハックは、これらの環境変数を使ってローダの処理を変更することで実現されています。

ローダはダイナミックリンカと呼ばれることもありますが、この記事では「ローダ」で統一します。

## `/lib64/ld-linux-x86-64.so.2` の問題点
`/lib64/ld-linux-x86-64.so.2` は GNU libc の一部として Linux にインストールされていますが、ソフトウェアとして見ると以下の2つの問題があります。

1つ目の問題は、GNU libcのソースコードは読みにくい点です。GNU libcは歴史の長いソフトウェアでC言語で書かれています。また、複数のアーキテクチャの移植可能な移植性を求められます。このため、ソースコードの至る部分でマクロが多用されており、プログラムの流れを追うのが難しくなっています。

2つ目の問題は、`libc.so` の初期化とプログラムのロードが同時に行われいて、ロード部分だけを分離して理解することができない点です。`libc.so` とはいわゆる標準Cライブラリで、バイナリが `/lib64/ld-linux-x86-64.so.2` によってロードされるときはほぼ確実に同時にロードされます。

問題の根本的な原因は、`libc.so` と `/lib64/ld-linux-x86-64.so.2` が同じパッケージに存在し、この2つのコンポーネントの役割分担が明示的にドキュメントされていないことです。このため、ロードだけ、もしくは `libc.so` だけを分離して理解し、別のソフトウェアに切り出すことは非常に難しくなっています。